import numpy as np
import pandas as pd

from zipline.utils import tradingcalendar
from quantopian.pipeline import CustomFactor, Pipeline
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline.data.builtin import USEquityPricing
from quantopian.pipeline.factors import AverageDollarVolume, Returns
from quantopian.pipeline.filters.morningstar import Q500US, Q1500US
from quantopian.pipeline.classifiers.morningstar import Sector
from quantopian.pipeline.data.zacks import EarningsSurprises
from quantopian.pipeline.data import morningstar as mstar
from quantopian.pipeline.data.eventvestor import EarningsCalendar
from quantopian.pipeline.data.eventvestor import BuybackAuthorizations
from quantopian.pipeline.factors.eventvestor import (
    BusinessDaysUntilNextEarnings,
    BusinessDaysSincePreviousEarnings,
    BusinessDaysSinceBuybackAuth
)

def initialize(context):
    """
    Called once at the start of the algorithm.
    """   
    context.leverage = 1.0
    context.DAYS_TO_HOLD = {'pead' : 6, 'reversal': 1, 'buyback': 25}
    context.RETURNS_LOOKBACK = 5
    context.MAX_IN_ONE = 1.
    
    context.pead_longs = {}
    context.pead_shorts = {}
    context.buyback_longs = {}
  
    schedule_function(rebalance_shorts, date_rules.every_day(), time_rules.market_open())
    schedule_function(rebalance_longs, date_rules.every_day(), time_rules.market_open())
    schedule_function(close_positions, date_rules.every_day(), time_rules.market_open())
    schedule_function(record_vars, date_rules.every_day(), time_rules.market_close())
    attach_pipeline(create_pipeline(context), 'pipe')
                
def create_pipeline(context):
    # Factors
    lag_e_surp = EarningsSurprises.eps_pct_diff_surp.latest
    adv = AverageDollarVolume(window_length=30, mask=USEquityPricing.volume.latest > 0,)    
    returns_quantile = Returns(
                window_length=context.RETURNS_LOOKBACK,
                mask=adv.notnan()
            ).quantiles(5)
    till_earnings = BusinessDaysUntilNextEarnings()
    since_buybacks = BusinessDaysSinceBuybackAuth()
    since_earnings = BusinessDaysSincePreviousEarnings()
    
    # Filters
    notnan = lag_e_surp.notnan()
    q500 = Q500US()
    q1500 = Q1500US()
    top_dec = lag_e_surp.percentile_between(90, 100, mask=q500)
    bottom_dec = lag_e_surp.percentile_between(0,10, mask=q500)
    has_announcement = BusinessDaysUntilNextEarnings().eq(1)
    adv_top_5 = adv.percentile_between(95,100)
    

    # PEAD Reversal stock picks
    pead_reversal_longs = has_announcement & bottom_dec & notnan & q500
    pead_reversal_shorts = has_announcement & top_dec & notnan & q500
    
    # Returns reversal stock
    reversal_longs = has_announcement & returns_quantile.eq(0) & adv_top_5 & q1500
    reversal_shorts = has_announcement & returns_quantile.eq(4)  & adv_top_5 & q1500
    buyback_longs = ((since_buybacks + till_earnings) <= 15) & q1500
    stocks = pead_reversal_longs | pead_reversal_shorts \
            | reversal_longs | reversal_shorts | buyback_longs
    
    return Pipeline(columns= {
                        'till_earnings': till_earnings,
                        'since_buybacks': since_buybacks,
                        'since_earnings': since_earnings,
                        'market_cap': mstar.valuation.market_cap.latest,
                        'buyback_unit': BuybackAuthorizations.previous_unit.latest,
                        'buyback_amount': BuybackAuthorizations.previous_amount.latest,
                        'buyback_longs': buyback_longs,
                        'pricing': USEquityPricing.close.latest,
                        'pead_reversal_longs': pead_reversal_longs,
                        'pead_reversal_shorts': pead_reversal_shorts,
                        'reversal_longs': reversal_longs,
                        'reversal_shorts': reversal_shorts
                    },
                    screen=stocks)

def convert_units(row):
    """Calculates 'Percent of SO' for each row"""
    buyback_unit = row['buyback_unit']
    market_cap = row['market_cap']
    shares_outstanding = market_cap/row['pricing']
    if buyback_unit == '$M':
        total_bought = row['buyback_amount'] * 1000000.0
        percent_bought = (total_bought)/market_cap
    elif buyback_unit == "Mshares":
        percent_bought = row['buyback_amount']/shares_outstanding
    elif buyback_unit == '%':
        percent_bought = row['buyback_amount']/100.0
    else:
        percent_bought = None
    row['Percent of SO'] = percent_bought
    return row

def before_trading_start(context, data):
    """Called every day before market open"""
    context.output = pipeline_output('pipe')

    # Currently held PEAD reversal picks get updated and dropped if held for longer than hold time        
    context.pead_longs = {k:v+1 for k,v in context.pead_longs.items() if v < context.DAYS_TO_HOLD['pead']}
    context.pead_shorts = {k:v+1 for k,v in context.pead_shorts.items() if v < context.DAYS_TO_HOLD['pead']}
    
    # Stocks picked by 5 day return reversals are reset (hold time is one day)
    context.reversal_longs = []
    context.reversal_shorts = []
    
    # New PEAD reversals positions from our pipeline
    for stock in context.output.index[context.output['pead_reversal_longs'] == True]:
        context.pead_longs[stock] = 0
    
    for stock in context.output.index[context.output['pead_reversal_shorts'] == True]:
        context.pead_shorts[stock] = 0
    
    # New 5 day return reversal positions from our pipeline
    for stock in context.output.index[context.output['reversal_longs'] == True]:
        if stock not in context.pead_longs and stock not in context.pead_shorts:
            context.reversal_longs.append(stock)
            
    for stock in context.output.index[context.output['reversal_shorts'] == True]:
        if stock not in context.pead_longs and stock not in context.pead_shorts:
            context.reversal_shorts.append(stock)
            
    # our aggregate long/short portfolio
    context.aggregate_longs = set(context.pead_longs.keys() + context.reversal_longs)
    context.aggregate_shorts = set(context.pead_shorts.keys() + context.reversal_shorts)
    
    # Stocks picked by buyback get updated and dropped if held for longer than hold time
    context.buyback_longs = {k:v+1 for k,v in context.buyback_longs.items() if \
                             (v < context.DAYS_TO_HOLD['buyback'] and \
                              v not in (context.aggregate_longs | context.aggregate_shorts))}
    
    context.aggregate_stocks = context.aggregate_longs | context.aggregate_shorts \
                               | set(context.buyback_longs.keys())
    
    # Edge case check, since we are doing row operations for new buyback picks
    if len(context.output.index) == 0:
        return

    # Compute 'Percent of SO', for each row
    buybacks = context.output.apply(lambda row: convert_units(row), axis=1)
    
    # Only pick buyback stocks which have 'Percent of SO' > .05
    buybacks = buybacks[buybacks['Percent of SO'] > .05]
    buybacks = buybacks.index[buybacks.buyback_longs]
    
    # New Buyback long picks                                                                            
    for stock in buybacks:
        if stock not in context.aggregate_stocks:
            context.buyback_longs[stock] = 0
            
    context.aggregate_longs = context.aggregate_longs | set(context.buyback_longs.keys())

def rebalance_shorts(context, data):
    """Manage short positions"""
    short_list = context.aggregate_shorts
    for equity in short_list:
        if data.can_trade(equity):
            order_target_percent(equity, -min(0.5 / len(short_list), context.MAX_IN_ONE))
            
def rebalance_longs(context, data):
    """Manage longs positions"""
    long_list = context.aggregate_longs
    for equity in long_list:
        if data.can_trade(equity):
            order_target_percent(equity, min(0.5 / len(long_list), context.MAX_IN_ONE))

def close_positions(context, data):
    for position in context.portfolio.positions:
        if position not in (context.aggregate_longs | context.aggregate_shorts):
            order_target_percent(position, 0)
            
def record_vars(context, data):
    """
    Plot variables at the end of each day.
    """
    record(leverage=context.account.leverage)
